---
title: "Summary plotting of metaBEAT output"
output: html_notebook
---

#This markdown notebook outlines step by step the processing of [metaBEAT](https://github.com/HullUni-bioinformatics/metaBEAT) output data to produce the figures using in Kitson *et al.* (2017)

###First of all clear the work space and read in the libraries that we need.
```{r}
rm(list=ls())
library(reshape2)
library(ggplot2)
library(gridExtra)
```

#Part 1: Minimum cluster depth analysis
First we need to see how the number of clusters retained and read depth per well changes with different minimum cluster sizes. We want to end up in a situation where we are retaining only the most common unique sequences as these are likely to be the real biological systems. We will ideally also avoid clustering with thresholds lower than 100% as this can pull in rare sequencing errors and result in a centroid that is not in fact a genuine biological sequence. We have already iterated across minimum cluster sizes in the [Jupyter notebook](https://github.com/HullUni-bioinformatics/Kitson_et_al_NMB/blob/master/notebook/OPM_NMB_conservative.ipynb) so now we will plot this data to help us choose a minimum cluster size.

```{r}
read.stats<-read.csv(file="data2/combined_read_stats.csv", stringsAsFactors=FALSE, header=TRUE)

### create a plot of number clusters in PCR wells by minimum cluster size
clusters<-ggplot(data = read.stats, aes(x=as.factor(clusters_min_cov), y=cluster_above_thres)) +
  geom_boxplot() +
  labs(y = "Clusters retained", x="Minimum cluster coverage")
### create a plot of read depth in PCR wells by minimum cluster size
reads<-ggplot(data = read.stats, aes(x=as.factor(clusters_min_cov), y=queries)) +
  geom_boxplot() +
  labs(y = "Per well read depth", x="Minimum cluster coverage")

### combine the plots and write them to an svg file
svg(file="diagrams/coverage.svg")
grid.arrange(clusters, reads, ncol=1)
dev.off()

### replot the abole plot here for convenience
grid.arrange(clusters, reads, ncol=1)
```

```{r}
### greedy regex to split the sample string by the underscore and leave us with a column for nest and a column for indentifier
read.stats<-cbind(read.stats, do.call(rbind, strsplit(as.character(read.stats$sample), "_|_.*_")))

### rename the last column as type
colnames(read.stats)[ncol(read.stats)]<-'template'
### process the last column into a sample type factor using a horrible ifelse statement
read.stats$type<-ifelse(read.stats$template=="neg1","Negative",
                          ifelse(read.stats$template=="neg2","Negative",
                            ifelse(read.stats$template=="DNApositive","DNApositive",
                              ifelse(read.stats$template=="PCRpositive","PCRpositive","Sample"))))
### make the type column a factor
read.stats$type<-as.factor(read.stats$type)
### drop the columns, we don't need
#read.stats<-read.stats[,c(1:(ncol(read.stats)-3),ncol(read.stats))]

### create a plot of number clusters in negative wells by minimum cluster size
neg.clusters<-ggplot(data = subset(read.stats, type=="Negative"), aes(x=as.factor(clusters_min_cov), y=cluster_above_thres)) +
  geom_boxplot() +
  labs(y = "Clusters retained", x="Minimum cluster coverage")
### create a plot of read depth in negative wells by minimum cluster size
neg.reads<-ggplot(data = subset(read.stats, type=="Negative"), aes(x=as.factor(clusters_min_cov), y=queries)) +
  geom_boxplot() +
  labs(y = "Per well read depth", x="Minimum cluster coverage")

### combine the plots and write them to an svg file
svg(file="diagrams/negatives_coverage.svg")
grid.arrange(neg.clusters, neg.reads, ncol=1)
dev.off()

### replot the abole plot here for convenience
grid.arrange(neg.clusters, neg.reads, ncol=1)
```


#Part 2: Main data analysis
In part one we decided on an appropriate minimum cluster size for our final analysis we then used this value in the [Jupyter note book]() to run a final analysis. Now we need to examine this output, check that negatives are clean and examine the contents of each well.

##Analysis of trimming process


###Read in the read statistics and metadata.
```{r}
### Read in the read stats
final.read.stats<-read.csv(file="data2/metaBEAT_read_stats.csv", stringsAsFactors = FALSE, header = TRUE)

### read in the sample metadata
my.plates<-read.table(file="data2/sample_metadata.tsv", stringsAsFactors=FALSE, header=TRUE, sep="\t")

### greedy regex to split the sample string by the underscore and leave us with a column for nest and a column for indentifier
my.plates<-cbind(my.plates, do.call(rbind, strsplit(as.character(my.plates$sample), "_|_.*_")))

### trim the plate data to the necessary columns (i.e. drop the identifier column)
my.plates<-my.plates[, c(1:3,5)]
### name the columns
colnames(my.plates)<-c("sample", "plate", "plate.numeric", "template")

### process the template column into a sample type factor using a horrible ifelse statement
my.plates$type<-ifelse(my.plates$template=="neg1","Negative",
                          ifelse(my.plates$template=="neg2","Negative",
                            ifelse(my.plates$template=="DNApositive","DNApositive",
                              ifelse(my.plates$template=="PCRpositive","PCRpositive","Moth sample"))))
```

###Merge the dataframes together using match and annotate the samples.
```{r}
### use match to add the plate data to the read data
final.read.stats$plate<-my.plates$plate[match(final.read.stats$sample, my.plates$sample)]
final.read.stats$plate.numeric<-my.plates$plate.numeric[match(final.read.stats$sample, my.plates$sample)]
final.read.stats$type<-my.plates$type[match(final.read.stats$sample, my.plates$sample)]

### set the plotting order of the plates
final.read.stats$plate<-factor(reorder(final.read.stats$plate, final.read.stats$plate.numeric))

### make sample and plate factors for faceting and ordering
final.read.stats$sample<-as.factor(final.read.stats$sample)
final.read.stats$plate<-as.factor(final.read.stats$plate)

### subset the data to only keep the numbers of reads at each stage
final.read.stats.subs<-subset(final.read.stats, select=c("sample", "total", "trimmed.total", "queries", "plate", "type"))

### melt the data into long format
final.read.stats.subs.melt<-melt(final.read.stats.subs, id.vars=c("sample", "type", "plate"))
```

###Plot the read depth by plate including positives and negatives.
```{r}
### make the ggplot object + add the jittered dots + add the boxplots and colour them by trim level and make them a bit transparent
all.samples<-ggplot(aes(y = value, x = plate, fill = variable), data = final.read.stats.subs.melt) +
  ### make the boxplot and suppress the outliers as we are plotting the points anyway
  geom_boxplot(aes(fill=variable), alpha=0.5, position = position_dodge(width = 0.85), outlier.shape = NA) +
  ### plot the points
  geom_point(pch = 21, position = position_jitterdodge()) +
  ### fix the axes titles
  labs(y = "Reads per PCR well", x="PCR plate") +
  scale_fill_discrete(name="Trim level", 
                      breaks=c("total", "trimmed.total", "queries"), 
                      labels=c("Raw reads", "Trimmed reads", "Reads in clusters")) +
  scale_x_discrete(expand = c(0, 0)) +
  scale_y_continuous(expand = c(0, 0)) +
  ### rotate the x-axis labels and resize the text for the svg
  theme(axis.text.x = element_text(size=rel(1.5), colour="black", angle=45, hjust=1), 
        axis.text.y = element_text(size=rel(1.5), colour="black", angle=45, hjust=1), 
        axis.title.y = element_text(size=rel(2), vjust=2), 
        axis.title.x = element_text(size=rel(2), vjust=-1.3), 
        legend.text = element_text(size = rel(2.5)), 
        legend.title = element_text(size = rel(2.5), vjust=1), 
        legend.position = "right", 
        legend.key.height=unit(2, "line"), 
        legend.key=element_blank(), 
        legend.background = element_blank(), 
        panel.background = element_blank(), 
        panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(), 
        axis.line = element_blank(), 
        panel.border = element_rect(colour = "black", fill=NA, size=1), 
        plot.margin=unit(c(0.1, 0.1, 1, 1), "lines"))

### Plot above as a svg
svg(file="diagrams/trimming_summary_all_samples.svg", 10, 10)
all.samples
dev.off()

### Plot above here for convenience
all.samples
```

###Plot the read depth by plate excluding positives and negatives.
```{r}
########################################################################################
################### Plot the data excluding the +ves and -ves  ###########################
########################################################################################

### make the ggplot object + add the jittered dots + add the boxplots and colour them by trim level and make them a bit transparent
samples.only<-ggplot(aes(y = value, x = plate, fill = variable), data = subset(final.read.stats.subs.melt, final.read.stats.subs.melt$type=="Moth sample")) +
  ### make the boxplot and suppress the outliers as we are plotting the points anyway
  geom_boxplot(aes(fill=variable), alpha=0.5, position = position_dodge(width = 0.85), outlier.shape = NA) +
  ### plot the points
  geom_point(pch = 21, position = position_jitterdodge()) +
  ### fix the axes titles
  labs(y = "Reads per PCR well", x="PCR plate") +
  scale_fill_discrete(name="Trim level", 
                      breaks=c("total", "trimmed.total", "queries"), 
                      labels=c("Raw reads", "Trimmed reads", "Reads in clusters")) +
  scale_x_discrete(expand = c(0, 0)) +
  scale_y_continuous(expand = c(0, 0)) +
  ### rotate the x-axis labels and resize the text for the svg
  theme(axis.text.x = element_text(size=rel(1.5), colour="black", angle=45, hjust=1), 
        axis.text.y = element_text(size=rel(1.5), colour="black", angle=45, hjust=1), 
        axis.title.y = element_text(size=rel(2), vjust=2), 
        axis.title.x = element_text(size=rel(2), vjust=-1.3), 
        legend.text = element_text(size = rel(2.5)), 
        legend.title = element_text(size = rel(2.5), vjust=1), 
        legend.position = "right", 
        legend.key.height=unit(2, "line"), 
        legend.key=element_blank(), 
        legend.background = element_blank(), 
        panel.background = element_blank(), 
        panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(), 
        axis.line = element_blank(), 
        panel.border = element_rect(colour = "black", fill=NA, size=1), 
        plot.margin=unit(c(0.1, 0.1, 1, 1), "lines"))


### Plot above as a svg
svg(file="diagrams/trimming_summary_moths_only.svg", 10, 10)
samples.only
dev.off()

### Plot above here for convenience
samples.only
```


###Plot the read depth by PCR well type
```{r}
########################################################################################
################### Plot the data by sample type  ###########################
########################################################################################
### order the sample types for plotting
final.read.stats.subs.melt$type <- factor(final.read.stats.subs.melt$type, 
                                levels=c("Moth sample", 
                                         "DNApositive", 
                                         "PCRpositive", 
                                         "Negative"))

### make the ggplot object + add the jittered dots + add the boxplots and colour them by trim level and make them a bit transparent
sample.types<-ggplot(aes(y = value, x = type, fill = variable), data = final.read.stats.subs.melt) +
  ### make the boxplot and suppress the outliers as we are plotting the points anyway
  geom_boxplot(aes(fill=variable), alpha=0.5, position = position_dodge(width = 0.85), outlier.shape = NA) +
  ### plot the points
  geom_point(pch = 21, position = position_jitterdodge()) +
  ### fix the axes titles
  labs(y = "Reads per PCR well", x="Sample type") +
  scale_fill_discrete(name="Trim level", 
                      breaks=c("total", "trimmed.total", "queries"), 
                      labels=c("Raw reads", "Trimmed reads", "Reads in clusters")) +
  scale_x_discrete(expand = c(0, 0)) +
  scale_y_continuous(expand = c(0, 0)) +
  ### rotate the x-axis labels and resize the text for the svg
  theme(axis.text.x = element_text(size=rel(1.5), colour="black", angle=45, hjust=1), 
        axis.text.y = element_text(size=rel(1.5), colour="black", angle=45, hjust=1), 
        axis.title.y = element_text(size=rel(2), vjust=2), 
        axis.title.x = element_text(size=rel(2), vjust=-1.3), 
        legend.text = element_text(size = rel(2.5)), 
        legend.title = element_text(size = rel(2.5), vjust=1), 
        legend.position = "right", 
        legend.key.height=unit(2, "line"), 
        legend.key=element_blank(), 
        legend.background = element_blank(), 
        panel.background = element_blank(), 
        panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(), 
        axis.line = element_blank(), 
        panel.border = element_rect(colour = "black", fill=NA, size=1), 
        plot.margin=unit(c(0.1, 0.1, 1, 1), "lines"))

### Plot above as a svg
svg(file="diagrams/trimming_summary_sample_types.svg", 10, 10)
sample.types
dev.off()

### Plot above here for convenience
sample.types
```

##Well composition
We now need to parse the assignments into a per well composition diagram and calculate percentage parasitism.

#Read in the assignment data
```{r}
my.assignments<-read.table(file="data2/metaBEAT_transpose.tsv", stringsAsFactors=FALSE, header=TRUE, sep="\t")
```

#Data processing
we need to process this data quite a bit to get it annotated, formatted and into the correct order for plotting
```{r}

```

